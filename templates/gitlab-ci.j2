# Generated by AutoPipe - Deterministic CI/CD Pipeline Generator
# Language: {{ stack.language }}
# Framework: {{ stack.framework }}
# Build Tool: {{ stack.build_tool }}

stages:
  - build
  - test
  - analyze
  - package
  - publish
  - deploy_staging
  - deploy_production

variables:
  DOCKER_BUILDKIT: "1"
  SONAR_HOST_URL: "${SONAR_HOST_URL:-http://sonarqube:9000}"
  SONAR_TOKEN: "$SONAR_TOKEN"
  # Nexus Repository URLs (use nexus hostname in Docker network)
  NEXUS_URL: "${NEXUS_URL:-http://nexus:8081}"
  PYPI_REPOSITORY_URL: "${PYPI_REPOSITORY_URL:-http://nexus:8081/repository/pypi-hosted/}"
  PYPI_USERNAME: "${PYPI_USERNAME:-admin}"
  PYPI_PASSWORD: "${PYPI_PASSWORD:-admin123}"
  NPM_REGISTRY_URL: "${NPM_REGISTRY_URL:-nexus:8081/repository/npm-hosted/}"
  NPM_TOKEN: "${NPM_TOKEN:-}"
  MAVEN_REPOSITORY_URL: "${MAVEN_REPOSITORY_URL:-http://nexus:8081/repository/maven-releases/}"
  NUGET_REPOSITORY_URL: "${NUGET_REPOSITORY_URL:-http://nexus:8081/repository/nuget-hosted/}"
{% if stack.language in ['java', 'kotlin'] %}
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"
  GRADLE_USER_HOME: "$CI_PROJECT_DIR/.gradle"
{% endif %}
{% if stack.language in ['nodejs', 'typescript'] %}
  NPM_CONFIG_CACHE: "$CI_PROJECT_DIR/.npm"
{% endif %}

{% set project_dir = (stack.project_root or '.') | replace('\\', '/') %}
{% set config_file = stack.config_file or '' %}
{% set lock_file = stack.package_manager_lock or '' %}

# --- CACHE CONFIGURATION ---
.cache_config:
  cache:
    key:
      files:
        {% if stack.language in ['java', 'kotlin'] and stack.build_tool == 'maven' %}
        - {{ project_dir }}/pom.xml
        {% elif stack.language in ['java', 'kotlin'] and stack.build_tool == 'gradle' %}
        - {{ project_dir }}/build.gradle*
        - {{ project_dir }}/gradle.properties
        {% elif stack.language == 'python' %}
        {% if stack.build_tool == 'poetry' %}
        - {{ project_dir }}/poetry.lock
        {% elif stack.build_tool == 'pipenv' %}
        - {{ project_dir }}/Pipfile.lock
        {% elif lock_file %}
        - {{ project_dir }}/{{ lock_file }}
        {% else %}
        - {{ project_dir }}/requirements.txt
        {% endif %}
        {% elif stack.language in ['nodejs', 'typescript'] %}
        {% if stack.build_tool == 'pnpm' %}
        - {{ project_dir }}/pnpm-lock.yaml
        {% elif stack.build_tool == 'yarn' %}
        - {{ project_dir }}/yarn.lock
        {% else %}
        - {{ project_dir }}/package-lock.json
        {% endif %}
        {% elif stack.language == 'go' %}
        - {{ project_dir }}/go.sum
        {% elif stack.language == 'dotnet' %}
        - {{ project_dir }}/*.csproj
        {% elif stack.language == 'php' %}
        - {{ project_dir }}/composer.lock
        {% endif %}
    paths:
      {% if stack.language in ['java', 'kotlin'] and stack.build_tool == 'maven' %}
      - .m2/repository
      {% elif stack.language in ['java', 'kotlin'] and stack.build_tool == 'gradle' %}
      - .gradle
      - build
      {% elif stack.language == 'python' %}
      - .venv
      - .cache/pip
      {% elif stack.language in ['nodejs', 'typescript'] %}
      - node_modules
      - .npm
      {% elif stack.language == 'go' %}
      - .go/pkg/mod
      {% elif stack.language == 'dotnet' %}
      - .nuget/packages
      {% elif stack.language == 'php' %}
      - vendor
      {% endif %}
    policy: pull-push

# --- BUILD JOB ---
build:
  stage: build
  extends: .cache_config
  image:
    {% if stack.language in ['java', 'kotlin'] %}
    {% if stack.build_tool == 'maven' %}
    name: maven:3.9-eclipse-temurin-{{ stack.java_version or '21' }}
    {% elif stack.build_tool == 'gradle' %}
    name: gradle:8-jdk{{ stack.java_version or '21' }}
    {% else %}
    name: eclipse-temurin:{{ stack.java_version or '21' }}
    {% endif %}
    {% elif stack.language == 'python' %}
    name: python:{{ stack.python_version or '3.12' }}-slim
    {% elif stack.language in ['nodejs', 'typescript'] %}
    name: node:{{ stack.node_version or '22' }}-alpine
    {% elif stack.language == 'go' %}
    name: golang:{{ stack.go_version or '1.22' }}-alpine
    {% elif stack.language == 'dotnet' %}
    name: mcr.microsoft.com/dotnet/sdk:{{ stack.dotnet_framework_version or '8.0' }}
    {% elif stack.language == 'php' %}
    name: composer:2
    {% endif %}
  script:
    {% if project_dir != '.' %}
    - cd {{ project_dir }}
    {% endif %}
    {% if stack.language in ['java', 'kotlin'] %}
    {% if stack.build_tool == 'maven' %}
    - mvn compile -B -DskipTests -Dmaven.plugin.validation=NONE || mvn compile -B -DskipTests
    {% elif stack.build_tool == 'gradle' %}
    - gradle assemble --no-daemon -x test --continue || gradle assemble --no-daemon -x test
    {% endif %}
    {% elif stack.language == 'python' %}
    # Install comprehensive build dependencies for C extensions
    - apt-get update && apt-get install -y --no-install-recommends gcc g++ make libffi-dev libssl-dev libpq-dev python3-dev && rm -rf /var/lib/apt/lists/*
    {% if stack.build_tool == 'poetry' %}
    - pip install --no-cache-dir poetry
    - poetry config virtualenvs.in-project true
    - poetry install --no-interaction --no-root || poetry install --no-interaction
    {% elif stack.build_tool == 'pipenv' %}
    - pip install --no-cache-dir pipenv
    - PIPENV_VENV_IN_PROJECT=1 pipenv install --deploy
    {% elif stack.build_tool == 'uv' %}
    - pip install --no-cache-dir uv
    - uv venv .venv
    - uv pip install -r requirements.txt
    {% elif stack.build_tool == 'conda' %}
    - conda env create -f environment.yml
    {% else %}
    - python -m venv .venv
    - source .venv/bin/activate
    - |
      if [ -f requirements.txt ]; then
        pip install -r requirements.txt
      elif [ -f pyproject.toml ]; then
        pip install -e ".[dev]" || pip install -e . || pip install .
      elif [ -f setup.py ]; then
        pip install -e ".[dev]" || pip install -e . || pip install .
      else
        echo "No Python dependency file found"
      fi
    {% endif %}
    {% elif stack.language in ['nodejs', 'typescript'] %}
    # Install system dependencies (git for packages, python3/make/g++ for node-gyp native modules)
    - apk add --no-cache git python3 make g++
    {% if stack.build_tool == 'pnpm' %}
    - corepack enable pnpm
    - pnpm install --frozen-lockfile || pnpm install
    {% if stack.language == 'typescript' or stack.framework in ['react', 'nextjs', 'vue', 'nuxt', 'angular', 'nestjs'] %}
    - pnpm run build || echo "Build script not found or failed"
    {% endif %}
    {% elif stack.build_tool == 'yarn' %}
    - yarn install --frozen-lockfile || yarn install
    {% if stack.language == 'typescript' or stack.framework in ['react', 'nextjs', 'vue', 'nuxt', 'angular', 'nestjs'] %}
    - yarn build || echo "Build script not found or failed"
    {% endif %}
    {% else %}
    - npm ci || npm install
    {% if stack.language == 'typescript' or stack.framework in ['react', 'nextjs', 'vue', 'nuxt', 'angular', 'nestjs'] %}
    - npm run build --if-present || echo "Build script not found"
    {% endif %}
    {% endif %}
    {% elif stack.language == 'go' %}
    # Install CGO dependencies
    - apk add --no-cache gcc musl-dev
    - go mod download
    - CGO_ENABLED=0 go build -v ./... || go build -v ./...
    {% elif stack.language == 'dotnet' %}
    - dotnet restore
    - dotnet build -c Release --no-restore
    {% elif stack.language == 'php' %}
    - composer install --no-dev --optimize-autoloader --no-interaction
    {% endif %}
  artifacts:
    paths:
      {% if stack.language in ['java', 'kotlin'] and stack.build_tool == 'maven' %}
      - {{ project_dir }}/target/
      {% elif stack.language in ['java', 'kotlin'] and stack.build_tool == 'gradle' %}
      - {{ project_dir }}/build/
      {% elif stack.language == 'python' %}
      # Using cache instead of artifacts for .venv (too large)
      # - {{ project_dir }}/.venv/
      {% elif stack.language in ['nodejs', 'typescript'] %}
      - {{ project_dir }}/node_modules/
      {% if stack.build_output_dir %}
      - {{ project_dir }}/{{ stack.build_output_dir }}/
      {% elif stack.framework == 'nextjs' %}
      - {{ project_dir }}/.next/
      {% elif stack.framework == 'nuxt' %}
      - {{ project_dir }}/.output/
      {% else %}
      - {{ project_dir }}/dist/
      {% endif %}
      {% elif stack.language == 'go' %}
      - {{ project_dir }}/
      {% elif stack.language == 'dotnet' %}
      - {{ project_dir }}/bin/
      - {{ project_dir }}/obj/
      {% elif stack.language == 'php' %}
      - {{ project_dir }}/vendor/
      {% endif %}
    expire_in: 1 hour

# --- TEST JOB ---
test:
  stage: test
  extends: .cache_config
  image:
    {% if stack.language in ['java', 'kotlin'] %}
    {% if stack.build_tool == 'maven' %}
    name: maven:3.9-eclipse-temurin-{{ stack.java_version or '21' }}
    {% elif stack.build_tool == 'gradle' %}
    name: gradle:8-jdk{{ stack.java_version or '21' }}
    {% else %}
    name: eclipse-temurin:{{ stack.java_version or '21' }}
    {% endif %}
    {% elif stack.language == 'python' %}
    name: python:{{ stack.python_version or '3.12' }}-slim
    {% elif stack.language in ['nodejs', 'typescript'] %}
    name: node:{{ stack.node_version or '22' }}-alpine
    {% elif stack.language == 'go' %}
    name: golang:{{ stack.go_version or '1.22' }}-alpine
    {% elif stack.language == 'dotnet' %}
    name: mcr.microsoft.com/dotnet/sdk:{{ stack.dotnet_framework_version or '8.0' }}
    {% elif stack.language == 'php' %}
    name: php:{{ stack.php_version or '8.2' }}-cli-alpine
    {% endif %}
  needs:
    - build
  script:
    {% if project_dir != '.' %}
    - cd {{ project_dir }}
    {% endif %}
    {% if stack.language in ['java', 'kotlin'] %}
    {% if stack.build_tool == 'maven' %}
    # Run tests with JaCoCo coverage report generation
    - mvn test jacoco:report -B -Dmaven.plugin.validation=NONE || mvn test -B || echo "Tests failed"
    # Show generated coverage files
    - ls -la target/site/jacoco/ 2>/dev/null || echo "No JaCoCo report generated (need jacoco-maven-plugin in pom.xml)"
    {% elif stack.build_tool == 'gradle' %}
    # Run tests with JaCoCo coverage report generation
    - gradle test jacocoTestReport --no-daemon --continue || gradle test --no-daemon || echo "Tests failed"
    # Show generated coverage files
    - ls -la build/reports/jacoco/test/ 2>/dev/null || echo "No JaCoCo report generated (need jacoco plugin in build.gradle)"
    {% endif %}
    {% elif stack.language == 'python' %}
    # Install comprehensive build dependencies for C extensions
    - apt-get update && apt-get install -y --no-install-recommends gcc g++ make libffi-dev libssl-dev libpq-dev python3-dev && rm -rf /var/lib/apt/lists/*
    {% if stack.build_tool == 'poetry' %}
    - pip install --no-cache-dir poetry
    - poetry config virtualenvs.in-project true
    # Install with all dev/test dependencies
    - poetry install --all-extras --with dev,test 2>/dev/null || poetry install --with dev 2>/dev/null || poetry install
    - poetry add --group dev pytest pytest-cov --no-interaction 2>/dev/null || true
    - poetry run pytest --junitxml=report.xml --cov=. --cov-report=xml --cov-report=html -v || echo "No tests found"
    {% elif stack.build_tool == 'pipenv' %}
    - pip install --no-cache-dir pipenv
    - pipenv run pytest --junitxml=report.xml --cov=. --cov-report=xml || echo "Tests failed"
    {% else %}
    - source .venv/bin/activate || (python -m venv .venv && source .venv/bin/activate)
    - pip install pytest pytest-cov
    # Install requirements.txt if it exists (may contain test dependencies like trio, trustme, etc.)
    - |
      if [ -f requirements.txt ]; then
        echo "Installing requirements.txt..."
        pip install -r requirements.txt 2>/dev/null || true
      fi
    # Install dev/test requirements files if they exist
    - |
      for req_file in requirements-dev.txt requirements-test.txt requirements_dev.txt requirements_test.txt dev-requirements.txt test-requirements.txt; do
        if [ -f "$req_file" ]; then
          echo "Installing $req_file..."
          pip install -r "$req_file" 2>/dev/null || true
        fi
      done
    # Install project with test dependencies (try common optional dependency names)
    - |
      if [ -f pyproject.toml ] || [ -f setup.py ]; then
        pip install -e ".[dev,test,tests,testing]" 2>/dev/null || 
        pip install -e ".[dev,test]" 2>/dev/null || 
        pip install -e ".[test]" 2>/dev/null || 
        pip install -e ".[dev]" 2>/dev/null || 
        pip install -e . 2>/dev/null || 
        pip install . || true
      fi
    # Run tests with coverage
    - |
      # Check if project has coverage config in pyproject.toml
      if grep -q "\[tool\.coverage" pyproject.toml 2>/dev/null; then
        echo "Using project's coverage configuration from pyproject.toml"
        pytest --junitxml=report.xml --cov --cov-report=xml --cov-report=html -v || echo "Tests failed or no tests found"
      else
        # Auto-detect source directory for coverage
        COV_SOURCE="."
        if [ -d "src" ]; then
          COV_SOURCE="src"
        else
          for dir in */; do
            dir_name="${dir%/}"
            case "$dir_name" in
              tests|test|docs|scripts|examples|.git|.venv|venv|build|dist|*.egg-info) continue ;;
            esac
            if [ -f "$dir_name/__init__.py" ]; then
              COV_SOURCE="$dir_name"
              break
            fi
          done
        fi
        echo "Coverage source: $COV_SOURCE"
        pytest --junitxml=report.xml --cov=$COV_SOURCE --cov-report=xml --cov-report=html -v || echo "Tests failed or no tests found"
      fi
    {% endif %}
    {% elif stack.language in ['nodejs', 'typescript'] %}
    # Install system dependencies
    - apk add --no-cache git python3 make g++
    {% if stack.build_tool == 'pnpm' %}
    - corepack enable pnpm
    - pnpm install --frozen-lockfile || pnpm install
    # Run tests with coverage - try multiple approaches
    - |
      mkdir -p coverage
      # Try Jest-style --coverage first
      if pnpm test -- --coverage --coverageReporters=lcov --coverageDirectory=coverage 2>/dev/null && [ -f coverage/lcov.info ]; then
        echo "Coverage generated with Jest --coverage flag"
      # Try nyc wrapper for mocha/other test frameworks
      elif pnpm exec nyc --reporter=lcov --report-dir=coverage pnpm test 2>/dev/null && [ -f coverage/lcov.info ]; then
        echo "Coverage generated with nyc wrapper"
      # Try test:coverage script
      elif pnpm run test:coverage 2>/dev/null && [ -f coverage/lcov.info ]; then
        echo "Coverage generated with test:coverage script"
      # Try coverage script
      elif pnpm run coverage 2>/dev/null && [ -f coverage/lcov.info ]; then
        echo "Coverage generated with coverage script"
      else
        echo "No coverage tool worked, running plain tests"
        pnpm test || echo "Tests failed or no test script found"
      fi
    {% elif stack.build_tool == 'yarn' %}
    - yarn install --frozen-lockfile || yarn install
    # Run tests with coverage - try multiple approaches
    - |
      mkdir -p coverage
      # Try Jest-style --coverage first
      if yarn test --coverage --coverageReporters=lcov --coverageDirectory=coverage 2>/dev/null && [ -f coverage/lcov.info ]; then
        echo "Coverage generated with Jest --coverage flag"
      # Try nyc wrapper for mocha/other test frameworks
      elif yarn exec nyc --reporter=lcov --report-dir=coverage yarn test 2>/dev/null && [ -f coverage/lcov.info ]; then
        echo "Coverage generated with nyc wrapper"
      # Try test:coverage script
      elif yarn run test:coverage 2>/dev/null && [ -f coverage/lcov.info ]; then
        echo "Coverage generated with test:coverage script"
      # Try coverage script
      elif yarn run coverage 2>/dev/null && [ -f coverage/lcov.info ]; then
        echo "Coverage generated with coverage script"
      else
        echo "No coverage tool worked, running plain tests"
        yarn test || echo "Tests failed or no test script found"
      fi
    {% else %}
    - npm ci || npm install
    # Run tests with coverage - try multiple approaches
    # 1. Jest style --coverage flag
    # 2. nyc wrapper for mocha-based projects
    # 3. test:coverage or coverage npm scripts
    - |
      mkdir -p coverage
      # Try Jest-style --coverage first
      if npm test -- --coverage --coverageReporters=lcov --coverageDirectory=coverage 2>/dev/null && [ -f coverage/lcov.info ]; then
        echo "Coverage generated with Jest --coverage flag"
      # Try nyc wrapper for mocha/other test frameworks
      elif npx nyc --reporter=lcov --report-dir=coverage npm test 2>/dev/null && [ -f coverage/lcov.info ]; then
        echo "Coverage generated with nyc wrapper"
      # Try test:coverage npm script
      elif npm run test:coverage 2>/dev/null && [ -f coverage/lcov.info ]; then
        echo "Coverage generated with test:coverage script"
      # Try coverage npm script
      elif npm run coverage 2>/dev/null && [ -f coverage/lcov.info ]; then
        echo "Coverage generated with coverage script"
      # Fallback - just run tests without coverage
      else
        echo "No coverage tool worked, running plain tests"
        npm test || echo "Tests failed or no test script found"
      fi
    {% endif %}
    # Show coverage results
    - ls -la coverage/ 2>/dev/null || echo "No coverage generated"
    - cat coverage/lcov.info 2>/dev/null | head -50 || echo "No lcov.info file"
    {% elif stack.language == 'go' %}
    # Install CGO dependencies
    - apk add --no-cache gcc musl-dev
    - go test -v -short -coverprofile=coverage.out ./... || echo "Some tests failed"
    {% elif stack.language == 'dotnet' %}
    - dotnet test --no-build -c Release --logger "junit;LogFilePath=report.xml" /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura
    {% elif stack.language == 'php' %}
    {% if stack.test_framework == 'pest' %}
    - ./vendor/bin/pest --coverage --coverage-clover=coverage.xml
    {% elif stack.test_framework == 'codeception' %}
    - ./vendor/bin/codecept run --coverage --coverage-xml
    {% else %}
    - ./vendor/bin/phpunit --coverage-clover=coverage.xml --log-junit=report.xml
    {% endif %}
    {% endif %}
  artifacts:
    when: always
    paths:
      # Coverage files for analyze job
      {% if stack.language == 'python' %}
      - {{ project_dir | replace('\\', '/') }}/coverage.xml
      - {{ project_dir | replace('\\', '/') }}/.coverage
      - {{ project_dir | replace('\\', '/') }}/htmlcov/
      {% elif stack.language in ['nodejs', 'typescript'] %}
      - {{ project_dir | replace('\\', '/') }}/coverage/
      {% elif stack.language == 'go' %}
      - {{ project_dir | replace('\\', '/') }}/coverage.out
      {% elif stack.language in ['java', 'kotlin'] and stack.build_tool == 'maven' %}
      - {{ project_dir | replace('\\', '/') }}/target/site/jacoco/
      - {{ project_dir | replace('\\', '/') }}/target/jacoco.exec
      {% elif stack.language in ['java', 'kotlin'] and stack.build_tool == 'gradle' %}
      - {{ project_dir | replace('\\', '/') }}/build/reports/jacoco/
      {% elif stack.language == 'php' %}
      - {{ project_dir | replace('\\', '/') }}/coverage.xml
      {% elif stack.language == 'dotnet' %}
      - {{ project_dir | replace('\\', '/') }}/**/coverage.cobertura.xml
      {% endif %}
    {% if stack.language in ['java', 'kotlin', 'python', 'dotnet', 'php'] %}
    reports:
      {% if stack.language in ['java', 'kotlin'] and stack.build_tool == 'maven' %}
      junit:
        - {{ project_dir | replace('\\', '/') }}/target/surefire-reports/*.xml
      {% elif stack.language in ['java', 'kotlin'] and stack.build_tool == 'gradle' %}
      junit:
        - {{ project_dir | replace('\\', '/') }}/build/test-results/test/*.xml
      {% elif stack.language == 'python' %}
      junit:
        - {{ project_dir | replace('\\', '/') }}/report.xml
      coverage_report:
        coverage_format: cobertura
        path: {{ project_dir | replace('\\', '/') }}/coverage.xml
      {% elif stack.language == 'dotnet' %}
      junit:
        - {{ project_dir | replace('\\', '/') }}/**/report.xml
      coverage_report:
        coverage_format: cobertura
        path: {{ project_dir | replace('\\', '/') }}/**/coverage.cobertura.xml
      {% elif stack.language == 'php' %}
      junit:
        - {{ project_dir | replace('\\', '/') }}/report.xml
      coverage_report:
        coverage_format: cobertura
        path: {{ project_dir | replace('\\', '/') }}/coverage.xml
      {% endif %}
    {% endif %}
    expire_in: 1 day
  # Allow test failures - real projects may have flaky or failing tests
  allow_failure: true
  retry:
    max: 2
    when: script_failure

# --- ANALYZE JOB (SonarQube) ---
analyze:
  stage: analyze
  image:
    {% if stack.language in ['java', 'kotlin'] and stack.build_tool == 'maven' %}
    name: maven:3.9-eclipse-temurin-{{ stack.java_version or '21' }}
    {% elif stack.language in ['java', 'kotlin'] and stack.build_tool == 'gradle' %}
    name: gradle:8-jdk{{ stack.java_version or '21' }}
    {% else %}
    name: sonarsource/sonar-scanner-cli:latest
    {% endif %}
  needs:
    - test
  dependencies:
    - test  # Download coverage artifacts from test job
  script:
    {% if project_dir != '.' %}
    - cd {{ project_dir }}
    {% endif %}
    # Debug: show coverage files available
    - ls -la coverage.xml .coverage *.xml 2>/dev/null || echo "Checking for coverage files..."
    {% if stack.language in ['java', 'kotlin'] and stack.build_tool == 'maven' %}
    # Run SonarQube analysis with JaCoCo coverage paths
    - mvn sonar:sonar -Dsonar.host.url=$SONAR_HOST_URL -Dsonar.login=$SONAR_TOKEN -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml,**/jacoco.xml -B
    {% elif stack.language in ['java', 'kotlin'] and stack.build_tool == 'gradle' %}
    # Run SonarQube analysis with JaCoCo coverage paths
    - gradle sonarqube -Dsonar.host.url=$SONAR_HOST_URL -Dsonar.login=$SONAR_TOKEN -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml,**/jacocoTestReport.xml --no-daemon
    {% else %}
    - |
      sonar-scanner \
        -Dsonar.projectKey={{ metadata.name }} \
        -Dsonar.projectName="{{ metadata.name }}" \
        -Dsonar.projectVersion="{{ metadata.version }}" \
        -Dsonar.working.directory=/tmp/sonarwork \
        {% if stack.source_dir %}
        -Dsonar.sources={{ stack.source_dir }} \
        {% else %}
        -Dsonar.sources=. \
        -Dsonar.exclusions="**/test/**,**/tests/**,**/*_test.*,**/*_test/**,**/node_modules/**,**/vendor/**" \
        {% endif %}
        {% if stack.test_dir %}
        -Dsonar.tests={{ stack.test_dir }} \
        {% elif stack.language == 'go' %}
        {# Go: tests are *_test.go files in the same directories as source code #}
        -Dsonar.test.inclusions="**/*_test.go" \
        {% else %}
        -Dsonar.tests=tests,test \
        -Dsonar.test.inclusions="**/test/**,**/tests/**,**/*_test.*" \
        {% endif %}
        {% if stack.language == 'python' %}
        -Dsonar.python.coverage.reportPaths=coverage.xml \
        {% elif stack.language in ['nodejs', 'typescript'] %}
        -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info \
        {% elif stack.language == 'go' %}
        -Dsonar.go.coverage.reportPaths=coverage.out \
        {% elif stack.language == 'php' %}
        -Dsonar.php.coverage.reportPaths=coverage.xml \
        {% elif stack.language == 'dotnet' %}
        -Dsonar.cs.opencover.reportsPaths="**/coverage.cobertura.xml,**/coverage/**/coverage.cobertura.xml" \
        {% endif %}
        -Dsonar.host.url=$SONAR_HOST_URL \
        -Dsonar.login=$SONAR_TOKEN
    {% endif %}
  allow_failure: true
  rules:
    - if: $SONAR_TOKEN
      when: on_success
    - when: never

# --- PACKAGE JOB (Docker Build) ---
package:
  stage: package
  image: docker:24-cli
  services:
    - name: docker:24-dind
      alias: docker
      command: ["--insecure-registry=gitlab.example.com:5050", "--insecure-registry=$CI_REGISTRY"]
  variables:
    DOCKER_TLS_CERTDIR: ""
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    DOCKER_BUILDKIT: "0"  # Disable BuildKit to avoid session issues with DinD
  needs:
    - build
    - test
  before_script:
    # Wait for Docker daemon to be ready
    - |
      for i in $(seq 1 30); do
        if docker info >/dev/null 2>&1; then
          echo "Docker daemon is ready"
          break
        fi
        echo "Waiting for Docker daemon... ($i/30)"
        sleep 2
      done
    # Login to registry (retry up to 3 times)
    - |
      for i in 1 2 3; do
        if docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY" 2>/dev/null; then
          echo "Docker login successful"
          break
        fi
        echo "Docker login attempt $i failed, retrying..."
        sleep 5
      done || echo "Docker login failed - continuing without push"
  script:
    {% if project_dir != '.' %}
    - |
      if [ -f "{{ project_dir }}/Dockerfile" ]; then
        docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA -f {{ project_dir }}/Dockerfile {{ project_dir }} && \
        docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest && \
        docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA && \
        docker push $CI_REGISTRY_IMAGE:latest || echo "Docker build/push failed"
      else
        echo "No Dockerfile found in {{ project_dir }} - skipping Docker build"
      fi
    {% else %}
    - |
      if [ -f "Dockerfile" ]; then
        docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA . && \
        docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest && \
        docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA && \
        docker push $CI_REGISTRY_IMAGE:latest || echo "Docker build/push failed"
      else
        echo "No Dockerfile found - skipping Docker build"
      fi
    {% endif %}
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: manual
      allow_failure: true

# --- PUBLISH JOB (Artifact Registry) ---
publish:
  stage: publish
  image:
    {% if stack.language in ['java', 'kotlin'] and stack.build_tool == 'maven' %}
    name: maven:3.9-eclipse-temurin-{{ stack.java_version or '21' }}
    {% elif stack.language in ['java', 'kotlin'] and stack.build_tool == 'gradle' %}
    name: gradle:8-jdk{{ stack.java_version or '21' }}
    {% elif stack.language == 'python' %}
    name: python:{{ stack.python_version or '3.12' }}-slim
    {% elif stack.language in ['nodejs', 'typescript'] %}
    name: node:{{ stack.node_version or '22' }}-alpine
    {% elif stack.language == 'dotnet' %}
    name: mcr.microsoft.com/dotnet/sdk:{{ stack.dotnet_framework_version or '8.0' }}
    {% elif stack.language == 'php' %}
    name: composer:2
    {% elif stack.language == 'go' %}
    name: golang:{{ stack.go_version or '1.22' }}-alpine
    {% endif %}
  needs:
    - build
    - test
  script:
    {% if project_dir != '.' %}
    - cd {{ project_dir }}
    {% endif %}
    {% if stack.language in ['java', 'kotlin'] and stack.build_tool == 'maven' %}
    # Create Maven settings.xml with Nexus credentials
    - |
      mkdir -p ~/.m2
      cat > ~/.m2/settings.xml << EOF
      <settings>
        <servers>
          <server>
            <id>nexus-releases</id>
            <username>${MAVEN_USERNAME}</username>
            <password>${MAVEN_PASSWORD}</password>
          </server>
          <server>
            <id>nexus-snapshots</id>
            <username>${MAVEN_USERNAME}</username>
            <password>${MAVEN_PASSWORD}</password>
          </server>
        </servers>
      </settings>
      EOF
    - mvn deploy -DskipTests -B -DaltDeploymentRepository=nexus-releases::default::${MAVEN_REPOSITORY_URL}
    {% elif stack.language in ['java', 'kotlin'] and stack.build_tool == 'gradle' %}
    - gradle publish --no-daemon -Pnexus.url=$MAVEN_REPOSITORY_URL -Pnexus.username=$MAVEN_USERNAME -Pnexus.password=$MAVEN_PASSWORD || echo "Publish requires publishing config in build.gradle"
    {% elif stack.language == 'python' %}
    {% if stack.build_tool == 'poetry' %}
    - pip install --no-cache-dir poetry
    - poetry config repositories.private $PYPI_REPOSITORY_URL
    - poetry publish --build --repository private -u $PYPI_USERNAME -p $PYPI_PASSWORD
    {% else %}
    - pip install --no-cache-dir twine build
    - python -m build
    - twine upload --repository-url $PYPI_REPOSITORY_URL -u $PYPI_USERNAME -p $PYPI_PASSWORD dist/*
    {% endif %}
    {% elif stack.language in ['nodejs', 'typescript'] %}
    # Configure npm to publish to Nexus registry
    - |
      # Create base64 encoded auth for Nexus
      NPM_AUTH=$(echo -n "${NPM_USERNAME}:${NPM_PASSWORD}" | base64)
      cat > .npmrc << EOF
      registry=${NPM_REGISTRY_URL}
      //${NPM_REGISTRY_URL#http*://}:_auth=${NPM_AUTH}
      always-auth=true
      EOF
    {% if stack.build_tool == 'pnpm' %}
    - corepack enable pnpm
    - pnpm publish --no-git-checks || echo "npm publish failed - check package.json and Nexus config"
    {% elif stack.build_tool == 'yarn' %}
    - yarn publish || echo "npm publish failed - check package.json and Nexus config"
    {% else %}
    - npm publish || echo "npm publish failed - check package.json and Nexus config"
    {% endif %}
    {% elif stack.language == 'dotnet' %}
    - dotnet pack -c Release --no-build -o ./nupkg
    - dotnet nuget push ./nupkg/*.nupkg --source $NUGET_REPOSITORY_URL --api-key $NUGET_API_KEY
    {% elif stack.language == 'php' %}
    - echo "Publishing to Packagist or private repository..."
    {% elif stack.language == 'go' %}
    - echo "Go modules are published via git tags"
    - echo "Run 'git tag vX.Y.Z' and 'git push origin vX.Y.Z' to publish"
    {% endif %}
  rules:
    - if: $CI_COMMIT_TAG
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
      allow_failure: true

# --- DEPLOY STAGING ---
deploy_staging:
  stage: deploy_staging
  # Use dtzar/helm-kubectl which has both kubectl and shell (sh/bash)
  image: dtzar/helm-kubectl:latest
  needs:
    - package
  before_script:
    # Check if KUBE variables are configured
    - |
      if [ -z "$KUBE_SERVER" ] || [ -z "$KUBE_TOKEN" ]; then
        echo "Kubernetes deployment not configured (KUBE_SERVER, KUBE_TOKEN required)"
        echo "Skipping deployment - set CI/CD variables to enable"
        exit 0
      fi
  script:
    - kubectl config set-cluster k8s --server=$KUBE_SERVER --insecure-skip-tls-verify=true
    - kubectl config set-credentials deployer --token=$KUBE_TOKEN
    - kubectl config set-context staging --cluster=k8s --user=deployer --namespace=staging
    - kubectl config use-context staging
    - |
      kubectl set image deployment/{{ metadata.name }} \
        {{ metadata.name }}=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA \
        --namespace=staging || echo "Deployment not found - may need to create it first"
    - kubectl rollout status deployment/{{ metadata.name }} --namespace=staging --timeout=300s || echo "Rollout status check failed"
  environment:
    name: staging
    url: https://staging.{{ metadata.name }}.example.com
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $KUBE_SERVER
      when: on_success
    - when: never

# --- DEPLOY PRODUCTION ---
deploy_production:
  stage: deploy_production
  # Use dtzar/helm-kubectl which has both kubectl and shell (sh/bash)
  image: dtzar/helm-kubectl:latest
  needs:
    - deploy_staging
  before_script:
    # Check if KUBE variables are configured
    - |
      if [ -z "$KUBE_SERVER" ] || [ -z "$KUBE_TOKEN" ]; then
        echo "Kubernetes deployment not configured (KUBE_SERVER, KUBE_TOKEN required)"
        echo "Skipping deployment - set CI/CD variables to enable"
        exit 0
      fi
  script:
    - kubectl config set-cluster k8s --server=$KUBE_SERVER --insecure-skip-tls-verify=true
    - kubectl config set-credentials deployer --token=$KUBE_TOKEN
    - kubectl config set-context production --cluster=k8s --user=deployer --namespace=production
    - kubectl config use-context production
    - |
      kubectl set image deployment/{{ metadata.name }} \
        {{ metadata.name }}=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA \
        --namespace=production || echo "Deployment not found - may need to create it first"
    - kubectl rollout status deployment/{{ metadata.name }} --namespace=production --timeout=300s || echo "Rollout status check failed"
  environment:
    name: production
    url: https://{{ metadata.name }}.example.com
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $KUBE_SERVER
      when: manual
    - when: never

{% if stack.is_multi_module %}
# --- MONOREPO/MULTI-MODULE CONFIGURATION ---
# This project has multiple modules: {{ stack.modules | join(', ') }}
# Consider using GitLab's rules:changes for module-specific pipelines

.module_rules:
  rules:
    {% for module in stack.modules %}
    - changes:
        - {{ module }}/**/*
      when: on_success
    {% endfor %}
    - when: never
{% endif %}
